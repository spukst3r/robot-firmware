-- Title: USB HID generic device demo
-- Author: Albert Faber, Copyright (c) 2008..2009, all rights reserved.
-- Adapted-by: -
-- Compiler: >=2.4i
-- 
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
-- 
-- Description: This sample implements a generic HID device. The advantage of a generic
-- HID device is that it can use the HID driver on the HOST operation system.
-- 
-- 
-- Sources: http://www.usb.org for USB specifications
-- 
-- Notes: compiled with following flags
--	-loader18 -no-fuse -no-variable-reuse
--	-no-variable-reuse must be used 
--  due to a compiler issue
--
-- ------------------------------------------------------
-- ------------------------------------------------------
--
--
-- compiled with following flags: -loader18 -no-fuse -no-variable-reuse
--
-- This file has been generated from:
--    * board: board_18f4550_af.jal
--    * test : test_usb_hid_generic.jal
--

;@jallib section chipdef
-- chip setup
include 18f2455

-- even though the external crystal is 20 MHz, the configuration is such that
-- the CPU clock is derived from the 96 Mhz PLL clock (div2), therefore set
-- target frequency to 48 MHz
pragma target clock       48_000_000


-- fuses
pragma target PLLDIV        P5          -- divide by 5 - 20MHZ_INPUT
pragma target CPUDIV        P2          -- OSC1_OSC2_SRC_1_96MHZ_PLL_SRC_2
pragma target USBPLL        F48MHZ      -- CLOCK_SRC_FROM_96MHZ_PLL_2
pragma target OSC           HS_PLL
pragma target FCMEN         DISABLED
pragma target IESO          DISABLED
pragma target PWRTE         DISABLED    -- power up timer
pragma target VREGEN        ENABLED     -- USB voltage regulator
;pragma target VOLTAGE       MINIMUM     -- brown out voltage
pragma target BROWNOUT      DISABLED    -- no brownout detection
pragma target WDTPS         P32K        -- watch dog saler setting
pragma target WDT           DISABLED    -- no watchdog
;pragma target CCP2MUX       ENABLED     -- CCP2 pin C1
pragma target PBADEN        DIGITAL     -- digital input port<0..4>
pragma target LPT1OSC       LOW_POWER   -- low power timer 1
pragma target MCLR          EXTERNAL    -- master reset on RE3
pragma target STVR          DISABLED    -- reset on stack over/under flow
pragma target LVP           DISABLED    -- no low-voltage programming
pragma target XINST         ENABLED     -- extended instruction set
pragma target DEBUG         DISABLED    -- background debugging
pragma target CP0           DISABLED    -- code block 0 not protected
pragma target CP1           DISABLED    -- code block 1 not protected
pragma target CP2           DISABLED    -- code block 2 not protected
;pragma target CP3           DISABLED    -- code block 3 not protected
pragma target CPB           DISABLED    -- bootblock code not write protected
pragma target CPD           DISABLED    -- eeprom code not write protected
pragma target WRT0          DISABLED    -- table writeblock 0 not protected
pragma target WRT1          DISABLED    -- table write block 1 not protected
pragma target WRT2          DISABLED    -- table write block 2 not protected
;pragma target WRT3          DISABLED    -- table write block 3 not protected
pragma target WRTB          DISABLED    -- bootblock not write protected
pragma target WRTD          DISABLED    -- eeprom not write protected
pragma target WRTC          DISABLED    -- config not write protected
pragma target EBTR0         DISABLED    -- table read block 0 not protected
pragma target EBTR1         DISABLED    -- table read block 1 not protected
pragma target EBTR2         DISABLED    -- table read block 2 not protected
;pragma target EBTR3         DISABLED    -- table read block 3 not protected
pragma target EBTRB         DISABLED    -- boot block not protected


include delay

;@jallib section serial

-- whether or not using the serial port
;const HAS_SERIAL_DEBUG_PORT = 0

if defined( HAS_SERIAL_DEBUG_PORT ) == true then

	const serial_hw_baudrate = 115_200
	
	include serial_hardware
	include format
	include print
	
	-- intialze serial device
	serial_hw_init()

	procedure serial_print_spc() is 
		serial_hw_write( " " )
	end procedure

	procedure serial_newline() is
		serial_hw_write( 10 )
		-- serial_hw_write( 13 )
	end procedure
end if



const bit USB_DEBUG = false
const bit USB_DEBUG_HIGH = false

const bit USB_HID_DEBUG = false
const bit USB_HID_DEBUG_HIGH = false
const byte USB_HID_ENDPOINT = 0x01


include usb_defs

const bit USB_EP0 = 1
const byte USB_EP0_OUT_SIZE = 8
const word USB_EP0_OUT_ADDR = ( USB_BASE_ADDRESS + 0x0010 )
const byte USB_EP0_IN_SIZE  = 8
const word USB_EP0_IN_ADDR  = ( USB_EP0_OUT_ADDR + USB_EP0_OUT_SIZE )

const bit USB_EP1 = 1
const byte USB_EP1_OUT_SIZE = 8
const word USB_EP1_OUT_ADDR = ( USB_EP0_IN_ADDR + USB_EP0_IN_SIZE )
const byte USB_EP1_IN_SIZE  = 8
const word USB_EP1_IN_ADDR  = ( USB_EP1_OUT_ADDR + USB_EP1_OUT_SIZE )

var volatile byte  usb_ep1in_buf[ 8 ] at USB_EP1_IN_ADDR

const bit USB_EP2 = 0
const byte USB_EP2_OUT_SIZE = 8
const word USB_EP2_OUT_ADDR = 0x0000
const byte USB_EP2_IN_SIZE  = 8
const word USB_EP2_IN_ADDR  = 0x0000

const bit USB_EP3 = 0
const byte USB_EP3_OUT_SIZE = 8
const word USB_EP3_OUT_ADDR = 0x0000
const byte USB_EP3_IN_SIZE = 8
const word USB_EP3_IN_ADDR  = 0x0000


const byte HID_OUT_REPORT_SIZE = 8

const byte USB_DEVICE_DESCRIPTOR[USB_DEVICE_DESCRIPTOR_SIZE] = {
	USB_DEVICE_DESCRIPTOR_SIZE, 	-- 18 bytes long
	USB_DT_DEVICE, 	-- DEVICE 01h
	0x00,
	0x02,		-- usb version 2.00
	0x00,		-- class
	0x00,		-- subclass
	0x00,		-- protocol
	0x08,		-- max packet size for end point 0
	0x25,
	0x09,		-- Vendor ID
	0x01,
	0x70,		-- Product ID
	0x01,
	0x00, 	    -- version 0.1 of the product
	0x01,		-- string 1 for manufacturer
	0x02,		-- string 2 for product
	0x00,		-- string 3 for serial number
	0x01		-- number of configurations
}	


const byte USB_HID_REPORT1[]=
{
	0x06, 0x00, 0xFF,
	0x09, 0x01,
	0xA1, 0x01,
	0x19, 0x01,
	0x29, 0x40,
	0x15, 0x00,
	0x26, 0xFF, 0x00,
	0x75, 0x08,
	0x95, 0x40,
	0x81, 0x00,
	0x19, 0x01,
	0x29, 0x40,
	0x91, 0x00,
	0xC0
}

const USB_CONFIGURATION_DESCRIPTOR_SIZE = 0x09 + 0x09 + 0x09 + 0x07 + 0x07

const byte USB_CONFIGURATION_DESCRIPTOR[ USB_CONFIGURATION_DESCRIPTOR_SIZE ]=
{	
	-- configuration descriptor - - - - - - - - - - 
	0x09,	-- length,
	USB_DT_CONFIGURATION,	-- descriptor_type

	USB_CONFIGURATION_DESCRIPTOR_SIZE,
	0x00,	-- total_length;
	
	0x01,	-- num_interfaces,
	0x01,	-- configuration_value,
	0x00,	-- configuration_string_id,
	0b10000000, -- attributes (bus powered, no remote wake up)
	100,	-- max_power; (200ma)

	-- interface descriptor - - - - - - - - - - - -
	0x09,	-- length,
	USB_DT_INTERFACE,	-- descriptor_type,
	0x00,	-- interface_number, (starts at zero)
	0x00,	-- alternate_setting, (no alternatives)
	0x02,	-- num_endpoints,
	USB_HID_INTF,	-- interface_class, (HID)
	0x00,	-- interface_subclass
	0x00,	-- interface_protocol
	0x00,	-- interface_string_id;
	
	-- hid descriptor - - - - - - - - - - - - - - -
	0x09,				-- length,
	USB_DT_HID,			-- descriptor_type;
	0x11,
	0x01,				-- hid_spec in BCD (1.11)
	0x00,				-- country_code, (0=not country specific)
	0x01,				-- num_class_descriptors, (1)
	USB_DT_HID_REPORT,	-- class_descriptor_type; (0x22 = report)
	(count( USB_HID_REPORT1 ) & 0xFF ),
	(count( USB_HID_REPORT1 ) >> 8 ),
	
	0x07,				-- length,
	USB_DT_ENDPOINT,	-- descriptor_type,
	0b10000001,			-- endpoint_address, (Endpoint 1, IN)
	USB_EPT_INT,			-- attributes; (Interrupt)
	USB_EP1_IN_SIZE,				
	0x00,				-- max_packet_size
	0x01,				-- interval (1ms)

	0x07,				-- length,
	USB_DT_ENDPOINT,	-- descriptor_type,
	0b00000001,			-- endpoint_address, (Endpoint 1, OUT)
	USB_EPT_INT,		-- attributes; (Interrupt)
	USB_EP1_OUT_SIZE,				
	0x00,				-- max_packet_size
	0x01				-- interval (1ms)
}

const byte USB_STRING0[] = 
{
	0x04,	-- bLength
	USB_DT_STRING,	-- bDescriptorType
	0x09,	-- wLANGID[0] (low byte)
	0x04	-- wLANGID[0] (high byte)
}

const byte USB_STRING1[20] = 
{
	20,				-- bLength
	USB_DT_STRING,	-- bDescriptorType
	"D", 0x00, 
	"i", 0x00, 
	"m", 0x00, 
	"a", 0x00, 
	"&", 0x00, 
	"I", 0x00, 
	"l", 0x00, 
	"i", 0x00,
	"a", 0x00
}

const byte USB_STRING2[30] = 
{
	30,				-- bLength
	USB_DT_STRING,	-- bDescriptorType
	"U", 0x00, 
	"S", 0x00, 
	"B", 0x00, 
	" ", 0x00, 
	"L", 0x00, 
	"E", 0x00, 
	"D", 0x00, 
	" ", 0x00, 
	"D", 0x00, 
	"e", 0x00, 
	"v", 0x00, 
	"i", 0x00, 
	"c", 0x00,
	"e", 0x00
}


include usb_drv_core


-- adc lib is horribly broken, it won't work K50 series, so disable for the time being
if ( 	(target_chip == PIC_18F14K50 ) |
		(target_chip == PIC_18F13K50 ) |
		(target_chip == PIC_18LF14K50 ) |
		(target_chip == PIC_18LF13K50 ) )then
	const bit no_analog = true
else
	const bit no_analog = true
end if
	
if !no_analog	then
	-------------------------------- ADC STUFF -------------------------------------
	const no_adc = 0x06
	const ADC_HARDWARE_NCHAN     = 1
	const ADC_HARDWARE_NVREF     = 0         ;number of external references
	const ADC_HARDWARE_RSOURCE   = 10_000    ;maximum source resistance
	const ADC_HARDWARE_HIGH_RESOLUTION = true ;true = high resolution = 10 bits
	
	-- get the library, after defining the constants
	include adc_hardware
	
	-- initialize the AD converter according to the above parameters
	-- LEFT JUSTIFIED, 16 TAD, FOSC / 64 
	ADCON2 = 0b_10_000_110
	adc_init()
	adc_on()
end if

-- -----------------------------------------------------------------------------

-- timer 0 offset value
const byte TMR0_OFFSET = 106

------------------------------------------------------------
-- TIMER 0 configuration
------------------------------------------------------------
-- Objection is to get a 0.1 millisecond delay
-- fclk = 48 Mhz => timer clk = fclk / 4 = 12 Mhz
-- required clock rate: 0.1 ms => 1 Khz
-- timer 0 should divide by => 12 Mhz / 1 KHz = 12000
-- set pre-scaler to 1:8 and count to 150
--
-- TMR0_OFFSET = ( 256 - 150 ) = 106
-- TMR0_delay=(256-TMR0_OFFSET)*4*prescaler/Fosc
-- TMR0_delay=(256-6)*4*4/20_000_000= 0.1 msec.
--
-- Init TMR0, free run mode,
------------------------------------------------------------

-- set timer 0, 8 bit mode, timer enabled
T0CON = 0b_11000_010

var word num_timer_ints = 0


var volatile bit usb_hid_can_tx = true

const byte USB_HID_REQ_HID 			= 0x21
const byte USB_HID_REQ_REPORT 		= 0x22
const byte USB_HID_REQ_PHYSDISCR	= 0x23

const byte USB_HCR_GET_REPORT		= 0x01
const byte USB_HCR_GET_IDLE			= 0x02
const byte USB_HCR_GET_PROTOCOL		= 0x03
const byte USB_HCR_SET_REPORT		= 0x09
const byte USB_HCR_SET_IDLE			= 0x0A
const byte USB_HCR_SET_PROTOCOL		= 0x0B

enable_digital_io()

alias IN1_A     is pin_B0
alias IN2_A     is pin_B1
alias IN1_B     is pin_B2
alias IN2_B     is pin_B3

var byte hid_tx_buffer[ HID_OUT_REPORT_SIZE ]
var bit send_tx = false

var bit adc_enabled = false

procedure stop() is
	pin_B0 = off
	pin_B1 = off
	pin_B2 = off
	pin_B3 = off
end procedure

procedure stop_tower() is
	pin_B4 = off
	pin_B5 = off
end procedure

procedure run_forward() is
	stop()
	pin_B0 = on
	pin_B2 = on
end procedure

procedure run_backward() is
	stop()
	pin_B1 = on
	pin_B3 = on
end procedure

procedure rotate_cw() is
	stop()
	pin_B0 = on
	pin_B3 = on
end procedure

procedure rotate_ccw() is
	stop()
	pin_B1 = on
	pin_B2 = on
end procedure

procedure rotate_tower_cw() is
	stop_tower()
	pin_B4 = on
end procedure

procedure rotate_tower_ccw() is
	stop_tower()
	pin_B5 = on
end procedure

-- TMR0 interrupt service routine
procedure timer_0_isr() is
    pragma interrupt

    if ( INTCON_TMR0IF )  then
        num_timer_ints = num_timer_ints + 1

        if ( num_timer_ints == 100 ) then
			-- send portA event
			hid_tx_buffer[ 0 ] = 0x10
			hid_tx_buffer[ 1 ] = PORTA
			
			send_tx = true        
		end if
        
        if ( num_timer_ints == 200 ) then
			-- send portB event
			hid_tx_buffer[ 0 ] = 0x11
			hid_tx_buffer[ 1 ] = PORTB
			
			send_tx = true        
		end if

        if ( num_timer_ints == 300 ) then
			-- send portC event
			hid_tx_buffer[ 0 ] = 0x12
			hid_tx_buffer[ 1 ] = PORTC
			
			send_tx = true        
		end if

        if ( num_timer_ints == 400 ) then
			-- send ADC event
			hid_tx_buffer[ 0 ] = 0x13
			
			send_tx = true        
		end if
		
        -- only send value every 100 ms second
        if ( num_timer_ints == 1000 ) then
        
        
			num_timer_ints = 0
			
			if adc_enabled then
				var byte adc_hbyte = 0x80
				var byte adc_lbyte = 0x00
				
				
if !no_analog then
				adc_read_bytes( 0 , adc_hbyte, adc_lbyte)
end if				
				-- send ADC event
				hid_tx_buffer[ 0 ] = 0x02
				hid_tx_buffer[ 1 ] = adc_hbyte
				hid_tx_buffer[ 2 ] = adc_lbyte
				
				send_tx = true        
			
			end if
        end if
        -- Do timer offset TMR0_OFFSET
        TMR0 = TMR0 + TMR0_OFFSET

        -- Clear timer 0 interrupt flag
        INTCON_TMR0IF = low
    end if
    
end procedure


procedure usb_ep_data_in_callback(byte in end_point, word in buffer_addr, byte in byte_count) is
    pragma inline
    if USB_HID_DEBUG_HIGH then
        const byte str[] = " EP data in: "
        const byte str1[] = " bytes "
        print_string(serial_hw_data,str)
        print_byte_hex(serial_hw_data,byte_count & 0xFF)
        print_string(serial_hw_data,str1)
    end if
    
    -- data has been sent, so do we need to send more?
    if (end_point == USB_HID_ENDPOINT) then
        -- it's the data end point
        usb_hid_can_tx = true
               
    end if

end procedure

procedure usb_ep_data_out_callback(byte in end_point, word in buffer_addr, byte in byte_count) is
    pragma inline

    var byte cdc_rx_next

    if USB_HID_DEBUG then
        const byte str[] = " EP data out: "
        const byte str1[] = " bytes "
        print_string(serial_hw_data,str)
        print_byte_hex(serial_hw_data,byte_count)
		serial_hw_write( " " )
        print_byte_hex(serial_hw_data, end_point )
        print_string(serial_hw_data,str1)
    end if

    -- We have some data!
    if (end_point == USB_HID_ENDPOINT) then
		var byte src_ptr[2] AT buffer_addr

		FSR1L = src_ptr[0]
		FSR1H = src_ptr[1]

		if USB_HID_DEBUG then
			serial_newline()
		end if
		
		var byte index
		var byte cmd
		for byte_count using index loop
			var byte value
			value = POSTINC1
			if index  == 0 then
				cmd = value
				hid_tx_buffer[ 0 ] = value
			end if
			if index  == 1 then
				hid_tx_buffer[ 1 ] = value
			end if
			
			if USB_HID_DEBUG then
				print_byte_hex(serial_hw_data,value)
				serial_hw_write( " " )
			end if
		end loop
		
	
		send_tx = true

		case cmd of
			0x01:
			block
				-- enable interrupts (timer 0 )
				INTCON_TMR0IE = high
				INTCON_GIE = high
			end block
			
			0x02:
			block
				-- enable interrupts (timer 0 )
				INTCON_TMR0IE = low
				INTCON_GIE = low
			end block

			0x03:
			block
				PORTC = hid_tx_buffer[ 1 ]
				if defined( HAS_SERIAL_DEBUG_PORT ) == true then    
				end if
			end block

			0x04:
			block
				adc_enabled = true
			end block

			0x05:
			block
				adc_enabled = false
			end block

			0x80:
			block
				run_forward()
			end block

			0x81:
			block
				run_backward()
			end block

			0x82:
			block
				rotate_cw()
			end block

			0x83:
			block
				rotate_ccw()
			end block

			0x84:
			block
				rotate_tower_cw()
			end block

			0x85:
			block
				rotate_tower_ccw()
			end block

			0x90:
			block
				stop()
			end block

			0x91:
			block
				stop_tower()
			end block

			otherwise
			block

			end block
		end case
	end if
	
	usb_prime_epx_out( end_point, USB_EP1_OUT_SIZE )
	
end procedure


include usb_drv




-- set port A and B to inputs
PORTA_direction  = 0b_1111_1111
PORTC_direction  = all_output
PORTB_direction  = all_output

pin_B0_direction = output
pin_B1_direction = output
pin_B2_direction = output
pin_B3_direction = output
pin_B7_direction = input

-- constants
const  byte str_welcome[] = "JAL USB Generic HID demo version 0.10\nplease wait (takes ~10 seconds) before the device is fully configured"

-- variables
var word i = 0
var bit usb_initialized = false

var byte hid_report_in[8]

var word ticks100us = 0
var bit enable_keyboard = false

procedure usb_tasks() is    
    -- Servicing Hardware
    -- use polling method
    usb_handle_isr()
    if ( send_tx ) then
		usb_send_data(USB_HID_ENDPOINT, hid_tx_buffer, count( hid_tx_buffer ), low )
		send_tx = false
    end if

end procedure

procedure usb_hid_tx_report( byte in hid_report_in[], byte in cnt ) is
	
	while ( usb_hid_can_tx == false ) loop
		usb_tasks()
	end loop
	usb_hid_can_tx = false
	usb_send_data(USB_HID_ENDPOINT, hid_report_in, cnt , low )
end procedure

-- --------------------------------

-- --------------------------------
-- interrupts? No thanks
while INTCON_GIE loop
    INTCON_GIE = false
end loop

if defined( HAS_SERIAL_DEBUG_PORT ) == high then
	-- put info on RS-232 serial line
	serial_newline()
	serial_newline()

	print_string(serial_hw_data, str_welcome )
	serial_newline()
end if

-- setup the USB device
usb_setup()

-- enable USB device
usb_enable_module()

-- enable digital inputs on port B
-- enable_digital_io()

ADCON1 = 0x0E

stop()

-- main loop
forever loop
	-- poll the usb ISR function on a regular base, in order to 
	-- serve the USB requests
	usb_tasks()

    -- check if USB device has been configured by the HOST
    if usb_is_configured()  then

		-- note user via serial line that USB has been configured
		if usb_initialized == false then
			usb_initialized = true
			
			if defined( HAS_SERIAL_DEBUG_PORT ) == true then			
				const  byte str[] = "USB device has been configured by the HOST!"
				print_string(serial_hw_data, str )
				serial_newline()

				-- now keyboard chars can be send to the host
				enable_keyboard = true
			end if
		end if
    end if

    
	if defined( HAS_SERIAL_DEBUG_PORT ) == true then    
		if PIR1_RCIF then
		end if
	end if	
    
end loop
